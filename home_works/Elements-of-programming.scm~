#lang scheme

;;Ex 1.3 sum of squares of two large numbers out of three
(define square (lambda (x) (* x x)))
(define sum-squares
  (lambda (a b) (+ (square a) (square b)))) 
(define sum-sq-large-two-nums
  (lambda (x y z)
    (cond ((and (>= x y) (>= y z))(sum-squares x y))
          ((and (>= x y) (<= y z))(sum-squares x z))
          ((and (<= x y) (>= x z)) (sum-squares x y))
          (else (sum-squares y z)))))

;;Ex 1.4
(define a-plus-abs-b
  (lambda (a b) ((if (> b 0) + -) a b)))
;; As we know, the language allows us to write combinations
;;whose operators are themselves compound expressions.
;;In our case the operator is expressed as an if expression.
;;we apply an addition operation if b is positive, soustraction otherwise.
;;in other words we are making addition with b replaced by absolute value.

;;Ex 1.5 Applicative versus normal evaluation
(define (proc) (proc))
(define (test x y) (if (= x 0) 0 y))
;; We gonna try to contrast the behavior of evaluating this
;;expression (test 0 (p)) for the two modes of evaluation
;;in the applicative mode, the interpreter will start to
;;evaluate the operator and operands of the combination before
;;applying the operator. But when it evalutes (proc), it causes
;;the interpreter to enter infinite loop (due to looping implementation
;;of proc), so the process never terminates.
;; In the other hand, using normal evaluation, avoids us to enter this infinite loop,
;;because the second operand is never evaluated, even in the body of test (x == 0)
;;(test 0 (proc)) in this case returns 0

;; Ex 1.6
;; In the new-if implementation, the two clauses given as arguments are always evaluated before applying new-if.
;;Without even looking at the result of the predicate, and this is not how case analysis works.
;;An "if" expression works like this: we evaluate only one clause based on the predicate.
;;If we use this "new-if" procedure, we have got a non-terminating loop; To go around this problem, we could instruct
;;the compiler to the normal evaluation strategy.

;;Ex 1.10: Ackermann's function
(define (acker x y)
  (cond ((= y 0) 0)
        ((= x 0) (* 2 y))
        ((= y 1) 2)
        (else (acker (- x 1) (acker x (- y 1))))))

(define f (lambda (n) (acker 0 n)))
(define g (lambda (n) (acker 1 n)))
(define h (lambda (n) (acker 2 n)))
(define k (lambda (n) (* 5 n n)))
;;f(n) computes 2*n
;;g(n) computes 2**n
;;k(n) computes 5*n*n

;;Ex 1.11
;;Let us consider a function f, such that f(n) = n if n < 3
;;and f(n) = f(n-1) + 2f(n-2) + 3f(n-3) for n >= 3
;;we gonna write two versions of procedures computing this function f
;;recursive process
(define (func-recur n)
  (cond ((< n 3) n)
        (else (+ (func-recur (- n 1))
                 (* 2 (func-recur (- n 2)))
                 (* 3 (func-recur (- n 3)))))))
;;An iterative version using four state variables
(define (func-iter n)
  (define (iter a b c m)
    (cond ((= m n) c)
          (else (iter b c (+ c (* 2 b) (* 3 a)) (+ m 1)))))
  (if (< n 3) n (iter 0 1 2 2)))

;;Ex 1.12
;;A procedure that computes the infamous Pascal's Triangle
(define (pascal column row)
  (if (or (= column 0) (= column row))
      1
      (+ (pascal (- column 1) (- row 1))
         (pascal column (- row 1)))))

;;EX 1.15
;;A procedure computing the function trigonometric sine
;;based on the approximation that sin x converges to x if x is
;;sufficiently small (x not greater than 0.1 radians)
;; and the trigonometric fact sin x = 3*sin(x/3) - 4*(sin(x/3))**3
;;reducing the size of the angle at each recursive call of this procedure sine
(define (sine angle)
  (if (not (> (abs angle) 0.1))
      angle
      (p (sine (/ angle 3.0)))))
(define p (lambda (x) (- (* 3 x) (* 4 (cube x)))))
(define cube (lambda (x) (* x x x)))
;;a- How many times the procedure p is applied when evaluating sine(12.15)
;;(sine 12.15)
;;(p (sine 4.05))
;;(p (p (sine 1.35)))
;;(p (p (p (sine .45))))
;;(p (p (p (p (sine .15)))))
;;(p (p (p (p (p (sine .05))))))
;;(p (p (p (p (p .05)))))
;;(p (p (p (p .1495))))
;;(p (p (p .435134)))
;;(p (p .975846))
;;(p -0.789563)
;;-0.399803
;;b- The process generated by applying the sine procedure is generally a recursive one.
;;Evaluating sine(12.15) means apllying the p procedure 5 times.
;;In order for our machine to carry out the evaluation of sine of some given angle,
;;it consumes time and space resources, that grows logarithmically with the input size.
;;because of the fact that the angle is reduced by a factor of 3 at each pass of the recursive process
;;We write then the comlplexity in time and space is O(log)

;;EX 1.16
;;Exponentiation using successive multiplying
;;recursive process
(define (expt b n)
  (if (= n 0) 1 (* b (expt b (- n 1)))))
;;iterative process
(define expt-iter 
  (lambda (b n)
    (define (iter counter result)
      (if (= counter 0)
          result
          (iter  (- counter 1) (* result b))))
    (iter n 1)))
;;both of these procedures consume time resources that grow linearly with the input size
;;(the exponent in our situation) O(N)
;;but the one evolving iteratively has O(1) in memory, uses only one stack each time (tail recursion)

;;It turns out we can come up with an improved implementation for the exponentiation  operation.
;;It consists of  using the squaring operation
;;If n is even we square our product and halve n, otherwise multiply by b and decriment n
;;keep doing this until we get to the base case n == 0
;;recusive process
(define (expt-fast b n) 
  (cond ((= n 0) 1)
        ((even? n) (square (expt-fast b (/ n 2))))
        (else (* b (expt-fast b (- n 1))))))
;;iterative process
(define expt-fast-iter
  (lambda (b n)
    (define (iter counter base product)
      (cond ((= counter 0) product)
            ((even? counter) (iter (/ counter 2) (square base) product))
            (else (iter (- counter 1) base (* base product)))))
    (iter n b 1)))
    
    
  

             





